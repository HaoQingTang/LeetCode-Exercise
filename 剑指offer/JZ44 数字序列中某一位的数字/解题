【C++】

一：直接计算
小于10,1~9，9个数字，9位
小于100,10~99,90个数字，180位
小于1000,100~999,900个数字，2700位
各个区间的上下限是[0,10),[10,100),[100,1000)...位数是1,2,3...

所以整体的解题步骤为： > 1. 先确定第n个数在哪个区间内； > 2. 再确定这个数属于哪个自然数； > 3. 最后所在自然数得出数字。

找到区间后，通过(n/位数+下限)找到所在区间对应的自然数；然后(n%位数)作为下标，找到自然数中的数字，也就是题目的第n个数字。

详细：
已知x位数共有9×10^x−1个，所有x位数的位数之和是x×9×10^x−1。
使用d 和count 分别表示当前遍历到的位数和当前位数下的所有整数的位数之和，初始时d=1，count=9。
每次将n 减去d×count，然后将d 加1，将count 乘以10，直到n≤d×count，此时的d 是目标数字所在整数的位数，n 是所有d 位数中从第一位到目标数字的位数。
为了方便计算目标数字，使用目标数字在所有d 位数中的下标进行计算，下标从0 开始计数。令index=n−1，则index 即为目标数字在所有d 位数中的下标，index 的最小可能取值是0。
得到下标index 之后，即可得到无限整数序列中的第n 位数字。

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param n int整型 
     * @return int整型
     */
    int findNthDigit(int n) {
        int l = 1, count = 9;
        int d = 1;    //位数
        while(n>(long)count*d){
            n -= count*d;
            l = l*10;
            count = count*10;
            d += 1;
        }
        int index = n-1;
        int digit= index/d+l;           //对应的自然数
        int digitnum = index%d;         //对应的自然数位数
        int num = digit/(int)(pow(10,d-digitnum-1))%10;
        return num;
    }
};
